# Prompt Engineering（提示工程）指南 —— TaskFlowInsight API实现

本指南提供在"API实现"模块相关的AI交互中（如代码生成、测试设计、性能分析、问题诊断等）可复用、可审计、可落地的提示模板与策略，确保结果稳定、结构化、可追溯。

> 原则：精准上下文、结构化输出、明确角色定位、可验证结果、渐进式细化。

## 1. 使用场景与输出契约
- 场景A：API接口代码生成
  - 目的：根据设计文档生成符合规范的API实现代码。
  - 输出：Java代码（含注释）、单元测试、使用示例。
- 场景B：异常安全机制设计
  - 目的：设计和实现完善的异常处理和错误隔离机制。
  - 输出：异常处理策略、代码模板、测试用例。
- 场景C：性能优化方案
  - 目的：分析性能瓶颈，提供优化建议和实现。
  - 输出：性能分析报告、优化代码、基准测试。
- 场景D：测试用例设计
  - 目的：生成全面的功能、异常、并发、性能测试。
  - 输出：JUnit5测试代码、测试计划、覆盖率报告。
- 场景E：问题诊断与修复
  - 目的：定位问题根因，提供修复方案。
  - 输出：问题分析、修复代码、验证方法。

## 2. 输入上下文规范（精准且完整）
- 元信息：
  - `module`: 固定为 `api-implementation`
  - `version`: 语义化版本，例如 `v1.0.0-mvp`
  - `component`: TFI / TaskContext / ExceptionHandler / TestFramework
- 需求描述（结构化）：
  - `functionality`: 功能需求列表
  - `constraints`: 性能、安全、兼容性约束
  - `dependencies`: 依赖的模块和组件
  - `examples`: 使用场景示例
- 技术规范：
  - `java_version`: 21
  - `framework`: Spring Boot 3.5.x
  - `test_framework`: JUnit5
  - `performance_target`: <5% CPU overhead

示例（输入片段，JSON）：
```json
{
  "module": "api-implementation",
  "version": "v1.0.0-mvp",
  "component": "TFI",
  "functionality": [
    "提供静态方法API",
    "支持任务追踪",
    "异常安全保障"
  ],
  "constraints": {
    "performance": "<5% CPU overhead",
    "thread_safety": "required",
    "backward_compatibility": "required"
  },
  "dependencies": ["ContextManager", "Session", "TaskNode"],
  "examples": ["TFI.startTask('login')", "TFI.log('message')"]
}
```

## 3. 模板库（可直接复用）

### 3.1 API接口实现生成
指令：
```
你是一名资深Java API设计专家。根据以下规范生成API实现代码：
- 角色：API架构师+Java开发专家
- 任务：生成TFI主类的完整实现
- 要求：
  1) 静态方法设计，简洁易用
  2) 完整的异常处理
  3) 性能优化（禁用状态快速返回）
  4) 线程安全保证
  5) 详细的JavaDoc注释
- 输出：
  1) Java源代码（TFI.java）
  2) 核心方法的单元测试
  3) 使用示例代码
- 约束：Java 21，Spring Boot 3.5.x，遵循KISS原则
- 输入：<设计文档>
```

输出结构示例：
```java
// TFI.java
package com.syy.taskflowinsight.api;

/**
 * TaskFlow Insight 主API类
 * 提供任务追踪的核心静态方法
 */
public final class TFI {
    // 实现代码...
}

// TFITest.java
class TFITest {
    @Test
    void testStartTask() {
        // 测试代码...
    }
}

// 使用示例
// Example.java
TFI.enable();
TFI.startTask("process-order");
TFI.log("Processing order: " + orderId);
TFI.endTask();
```

### 3.2 异常安全机制设计
指令：
```
你是异常处理和容错设计专家。设计API层的异常安全机制：
- 目标：内部错误不影响业务逻辑
- 策略：
  1) 分层异常处理
  2) 错误隔离边界
  3) 降级策略
  4) 错误恢复机制
- 输出格式：
  {"strategy":"描述","implementation":"代码","test":"测试用例","metrics":"监控指标"}
- 不输出思维过程，直接给出方案
- 输入：<异常场景列表>
```

输出示例：
```json
{
  "strategy": "三层防护：API层捕获、Context层验证、Model层校验",
  "implementation": "try-catch包装+状态验证+数据完整性检查",
  "test": "异常注入测试+错误传播验证+恢复测试",
  "metrics": "error_rate, recovery_time, business_impact"
}
```

### 3.3 性能优化方案生成
指令：
```
你是Java性能优化专家。分析并优化API实现的性能：
- 分析维度：
  1) CPU开销分析
  2) 内存使用评估
  3) 锁竞争检测
  4) GC压力评估
- 优化策略：
  1) 快速路径优化
  2) 对象池化
  3) 无锁设计
  4) 批量处理
- 输出：
  1) 性能瓶颈分析（Markdown表格）
  2) 优化代码实现
  3) 基准测试代码（JMH）
- 目标：启用<5%开销，禁用<0.1%开销
- 输入：<当前实现代码>
```

### 3.4 测试用例全覆盖设计
指令：
```
你是测试设计专家。为API实现生成全面的测试用例：
- 测试类型：
  1) 功能测试：正常路径、边界条件
  2) 异常测试：各类异常场景
  3) 并发测试：多线程、竞态条件
  4) 性能测试：吞吐量、延迟
  5) 集成测试：与其他模块交互
- 输出格式：JUnit5测试代码
- 覆盖要求：
  - 代码覆盖率>90%
  - 分支覆盖率>85%
  - 异常路径100%覆盖
- 输入：<API接口列表>
```

### 3.5 问题诊断与修复
指令：
```
你是问题诊断专家。分析API实现中的问题并提供修复方案：
- 诊断步骤：
  1) 症状分析
  2) 根因定位
  3) 影响评估
  4) 修复方案
  5) 验证方法
- 输出JSON：
  {
    "symptom": "问题表现",
    "root_cause": "根本原因",
    "impact": "影响范围",
    "fix": "修复代码",
    "validation": "验证步骤",
    "prevention": "预防措施"
  }
- 输入：<问题描述+日志+代码>
```

## 4. 高级提示技巧

### 4.1 角色强化
```
你现在是TaskFlowInsight项目的首席API架构师，拥有15年Java开发经验，
精通高并发、分布式系统设计。你设计的API被数百万开发者使用。
请以这个身份和经验水平来完成以下任务...
```

### 4.2 链式思考引导
```
请按以下步骤思考和实现：
Step 1: 分析需求，识别关键约束
Step 2: 设计API接口签名
Step 3: 实现核心逻辑
Step 4: 添加异常处理
Step 5: 优化性能
Step 6: 编写测试
每步输出关键决策和代码
```

### 4.3 对比分析提示
```
对比以下两种实现方案：
方案A：静态方法 + ThreadLocal
方案B：单例模式 + 依赖注入
从性能、易用性、可测试性、扩展性四个维度分析，
给出最终推荐和理由。
```

### 4.4 增量改进提示
```
基于当前代码，进行渐进式改进：
Version 1: 基础功能实现
Version 2: 添加异常处理
Version 3: 性能优化
Version 4: 监控和诊断
每个版本给出改动diff和改进说明
```

## 5. 质量保障规范

### 5.1 代码质量检查
- 命名规范：类名、方法名、变量名符合Java规范
- 注释完整：JavaDoc、行内注释、TODO标记
- 异常处理：所有异常都被正确处理
- 资源管理：try-with-resources、正确关闭
- 线程安全：并发场景下的正确性

### 5.2 输出验证要求
- 可编译性：生成的代码必须可编译
- 可运行性：包含main方法或测试用例
- 可测试性：提供单元测试验证
- 性能指标：包含性能测试和结果

### 5.3 文档完整性
- API文档：每个公开方法的JavaDoc
- 使用示例：典型场景的代码示例
- 设计说明：关键决策和权衡
- 测试文档：测试计划和结果

## 6. 常见陷阱与解决

### 6.1 过度设计
- 问题：生成过于复杂的实现
- 解决：强调KISS原则，要求最简实现

### 6.2 性能忽视
- 问题：未考虑性能影响
- 解决：明确性能指标，要求基准测试

### 6.3 异常泄漏
- 问题：异常影响业务逻辑
- 解决：强调异常隔离，要求异常测试

### 6.4 线程不安全
- 问题：并发场景下出错
- 解决：要求并发测试，使用线程安全组件

## 7. 最佳实践清单
- [ ] 明确角色定位
- [ ] 提供结构化输入
- [ ] 要求具体输出格式
- [ ] 包含质量约束
- [ ] 提供示例参考
- [ ] 要求测试验证
- [ ] 迭代优化提示
- [ ] 保存成功案例

## 8. 提示模板管理
- 版本控制：为模板标记版本号
- 效果评估：记录使用效果和改进点
- 持续优化：根据反馈更新模板
- 知识沉淀：将成功案例转为模板

---
以上模板与规范面向API实现模块在开发、测试、优化、诊断等场景的AI协作需求。使用时应根据具体任务选择合适的模板，并根据实际效果持续优化。