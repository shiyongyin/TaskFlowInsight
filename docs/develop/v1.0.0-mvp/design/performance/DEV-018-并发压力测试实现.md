# DEV-018: 并发压力测试实现

## 任务概述
**任务编号**: DEV-018  
**任务名称**: 并发压力测试实现  
**所属模块**: 性能测试模块  
**任务类型**: 压力测试开发  
**优先级**: 高  
**预估工时**: 2天  
**前置依赖**: 
- DEV-010: TFI主API实现
- DEV-016: API性能基准测试
- DEV-017: 内存泄漏检测

## 业务需求
TaskFlowInsight设计目标支持1000+并发线程，需要设计全面的并发压力测试来验证系统在极限负载下的表现。测试应该发现潜在的并发问题、性能瓶颈和竞态条件，确保系统在高并发场景下的功能正确性和性能稳定性。

## 技术规格

### 核心功能
1. **并发测试框架**
   - 支持可配置的并发线程数（最高2000线程）
   - 多种压力测试场景和负载模式
   - 实时性能监控和数据收集
   - 可扩展的测试场景定义

2. **压力测试场景**
   - 基础API调用压力测试
   - 嵌套任务压力测试
   - 混合操作随机压力测试
   - 故障注入和恢复测试

3. **并发正确性验证**
   - 线程隔离性验证
   - 数据一致性检查
   - 资源争用安全性测试
   - 异常安全性验证

4. **性能度量和分析**
   - 吞吐量和延迟统计
   - 错误率和成功率分析
   - 资源使用监控
   - 性能退化检测

### 性能要求
- 基础并发：100线程下错误率<0.1%
- 高并发：1000线程下错误率<1%
- 极限并发：2000线程下系统不崩溃
- 吞吐量保持：高并发下吞吐量降幅<50%

## 技术实现

### 文件结构
```
src/test/java/com/syy/taskflowinsight/concurrent/
├── ConcurrentStressTestFramework.java   # 并发测试框架主类
├── StressTestScenario.java              # 压力测试场景接口
├── TFIStressTestScenarios.java          # TFI压力测试场景实现
├── ConcurrencyCorrectnessValidator.java # 并发正确性验证器
├── FaultInjectionStressTest.java        # 故障注入测试
├── TestMetrics.java                     # 测试度量工具
├── StressTestReporter.java              # 压力测试报告生成器
└── scenarios/
    ├── BasicAPIStressScenario.java      # 基础API压力场景
    ├── NestedTasksStressScenario.java   # 嵌套任务压力场景
    ├── MixedOperationsScenario.java     # 混合操作场景
    └── ErrorRecoveryScenario.java       # 错误恢复场景
```

### 核心实现

#### 1. 并发测试框架
```java
public final class ConcurrentStressTestFramework {
    private static final Logger LOGGER = LoggerFactory.getLogger(ConcurrentStressTestFramework.class);
    
    // 测试配置
    private final int maxConcurrentThreads;
    private final Duration testDuration;
    private final ExecutorService executorService;
    private final CountDownLatch completionLatch;
    private final ConcurrentHashMap<String, TestMetrics> metricsMap;
    private final AtomicBoolean testRunning;
    private final ScheduledExecutorService monitoringExecutor;
    
    public ConcurrentStressTestFramework(int maxThreads, Duration duration) {
        this.maxConcurrentThreads = maxThreads;
        this.testDuration = duration;
        this.executorService = Executors.newFixedThreadPool(
            maxThreads,
            new ThreadFactory() {
                private final AtomicInteger counter = new AtomicInteger();
                @Override
                public Thread newThread(Runnable r) {
                    return new Thread(r, "StressTest-" + counter.incrementAndGet());
                }
            }
        );
        this.completionLatch = new CountDownLatch(maxThreads);
        this.metricsMap = new ConcurrentHashMap<>();
        this.testRunning = new AtomicBoolean(false);
        this.monitoringExecutor = Executors.newSingleThreadScheduledExecutor();
    }
    
    public StressTestResult runStressTest(StressTestScenario scenario) {
        LOGGER.info("Starting stress test with {} threads for duration {}", 
            maxConcurrentThreads, testDuration);
        
        long startTime = System.currentTimeMillis();
        testRunning.set(true);
        
        // 启动系统监控
        startSystemMonitoring();
        
        // 启动所有测试线程
        for (int i = 0; i < maxConcurrentThreads; i++) {
            final int threadIndex = i;
            executorService.submit(() -> runThreadScenario(scenario, threadIndex));
        }
        
        // 等待测试完成或超时
        boolean completed = awaitCompletion();
        long endTime = System.currentTimeMillis();
        
        testRunning.set(false);
        stopSystemMonitoring();
        
        return buildTestResult(startTime, endTime, completed);
    }
    
    private void runThreadScenario(StressTestScenario scenario, int threadIndex) {
        String threadName = "stress-test-" + threadIndex;
        TestMetrics metrics = new TestMetrics(threadName);
        metricsMap.put(threadName, metrics);
        
        long endTime = System.currentTimeMillis() + testDuration.toMillis();
        
        try {
            while (System.currentTimeMillis() < endTime && testRunning.get()) {
                try {
                    long operationStart = System.nanoTime();
                    
                    // 执行测试场景
                    scenario.executeOperation(threadIndex);
                    
                    long operationEnd = System.nanoTime();
                    metrics.recordOperation(operationEnd - operationStart);
                    
                    // 可选的线程间协调
                    if (scenario.requiresCoordination()) {
                        scenario.coordinateThreads(threadIndex);
                    }
                    
                    // 可选的休眠间隔
                    if (scenario.getOperationInterval().toMillis() > 0) {
                        Thread.sleep(scenario.getOperationInterval().toMillis());
                    }
                    
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                } catch (Exception e) {
                    metrics.recordError(e);
                    LOGGER.debug("Error in thread {}: {}", threadIndex, e.getMessage());
                }
            }
        } finally {
            completionLatch.countDown();
            LOGGER.debug("Thread {} completed with {} operations, {} errors", 
                threadIndex, metrics.getOperationCount(), metrics.getErrorCount());
        }
    }
    
    private void startSystemMonitoring() {
        monitoringExecutor.scheduleAtFixedRate(
            this::captureSystemMetrics,
            0,
            1000,
            TimeUnit.MILLISECONDS
        );
    }
    
    private void captureSystemMetrics() {
        if (!testRunning.get()) return;
        
        try {
            SystemMetrics metrics = SystemMetrics.capture();
            // 存储系统指标用于后续分析
            recordSystemMetrics(metrics);
        } catch (Exception e) {
            LOGGER.warn("Error capturing system metrics", e);
        }
    }
    
    private boolean awaitCompletion() {
        try {
            return completionLatch.await(
                testDuration.toMillis() + 30000,
                TimeUnit.MILLISECONDS
            );
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return false;
        }
    }
}
```

#### 2. 压力测试场景定义
```java
@FunctionalInterface
public interface StressTestScenario {
    void executeOperation(int threadIndex) throws Exception;
    
    default boolean requiresCoordination() {
        return false;
    }
    
    default void coordinateThreads(int threadIndex) throws Exception {
        // 默认无协调
    }
    
    default Duration getOperationInterval() {
        return Duration.ZERO;
    }
    
    default String getScenarioName() {
        return this.getClass().getSimpleName();
    }
}

public final class TFIStressTestScenarios {
    
    /**
     * 基础API调用压力测试
     */
    public static final StressTestScenario BASIC_API_STRESS = new StressTestScenario() {
        @Override
        public void executeOperation(int threadIndex) throws Exception {
            TaskContext ctx = TFI.start("stress-task-" + threadIndex);
            try {
                // 模拟业务逻辑
                Thread.sleep(ThreadLocalRandom.current().nextInt(1, 5));
                TFI.message("Message from thread " + threadIndex);
            } finally {
                TFI.stop();
            }
        }
        
        @Override
        public String getScenarioName() {
            return "BasicAPIStress";
        }
    };
    
    /**
     * 嵌套任务压力测试
     */
    public static final StressTestScenario NESTED_TASKS_STRESS = new StressTestScenario() {
        @Override
        public void executeOperation(int threadIndex) throws Exception {
            TaskContext outer = TFI.start("outer-" + threadIndex);
            try {
                TaskContext inner1 = TFI.start("inner1-" + threadIndex);
                try {
                    TaskContext inner2 = TFI.start("inner2-" + threadIndex);
                    try {
                        TFI.message("Deep nested message from " + threadIndex);
                        // 模拟处理时间
                        Thread.sleep(ThreadLocalRandom.current().nextInt(1, 3));
                    } finally {
                        TFI.stop(); // inner2
                    }
                } finally {
                    TFI.stop(); // inner1
                }
            } finally {
                TFI.stop(); // outer
            }
        }
        
        @Override
        public String getScenarioName() {
            return "NestedTasksStress";
        }
    };
    
    /**
     * 随机操作混合压力测试
     */
    public static final StressTestScenario MIXED_OPERATIONS_STRESS = new StressTestScenario() {
        @Override
        public void executeOperation(int threadIndex) throws Exception {
            Random random = ThreadLocalRandom.current();
            int operation = random.nextInt(5);
            
            switch (operation) {
                case 0: // 简单任务
                    TaskContext ctx = TFI.start("simple-" + threadIndex);
                    TFI.stop();
                    break;
                    
                case 1: // 带消息任务
                    TaskContext ctx2 = TFI.start("message-task-" + threadIndex);
                    TFI.message("Random message " + random.nextInt());
                    TFI.stop();
                    break;
                    
                case 2: // 嵌套任务
                    TaskContext outer = TFI.start("nested-outer-" + threadIndex);
                    TaskContext inner = TFI.start("nested-inner-" + threadIndex);
                    TFI.stop(); // inner
                    TFI.stop(); // outer
                    break;
                    
                case 3: // 导出操作
                    String json = TFI.exportJson();
                    // 验证导出结果不为空
                    if (json == null || json.isEmpty()) {
                        throw new IllegalStateException("Export returned empty result");
                    }
                    break;
                    
                case 4: // 打印树操作
                    TFI.printTree();
                    break;
            }
        }
        
        @Override
        public String getScenarioName() {
            return "MixedOperationsStress";
        }
    };
    
    /**
     * 错误恢复压力测试
     */
    public static final StressTestScenario ERROR_RECOVERY_STRESS = new StressTestScenario() {
        @Override
        public void executeOperation(int threadIndex) throws Exception {
            TaskContext ctx = TFI.start("error-recovery-" + threadIndex);
            try {
                // 10%的概率抛出异常
                if (ThreadLocalRandom.current().nextInt(10) == 0) {
                    throw new RuntimeException("Simulated error in thread " + threadIndex);
                }
                
                TFI.message("Normal operation in thread " + threadIndex);
                Thread.sleep(ThreadLocalRandom.current().nextInt(1, 3));
                
            } catch (RuntimeException e) {
                TFI.message("Error occurred: " + e.getMessage());
                // 模拟错误恢复
                Thread.sleep(5);
            } finally {
                TFI.stop();
            }
        }
        
        @Override
        public String getScenarioName() {
            return "ErrorRecoveryStress";
        }
    };
}
```

#### 3. 并发正确性验证器
```java
public final class ConcurrencyCorrectnessValidator {
    
    /**
     * 验证线程隔离性
     */
    @Test
    @DisplayName("线程隔离性验证 - 1000线程")
    public void testThreadIsolation() throws InterruptedException {
        int threadCount = 1000;
        ExecutorService executor = Executors.newFixedThreadPool(threadCount);
        CountDownLatch latch = new CountDownLatch(threadCount);
        ConcurrentHashMap<Long, String> threadSessions = new ConcurrentHashMap<>();
        AtomicInteger successCount = new AtomicInteger();
        AtomicInteger errorCount = new AtomicInteger();
        
        long startTime = System.currentTimeMillis();
        
        for (int i = 0; i < threadCount; i++) {
            final int threadIndex = i;
            executor.submit(() -> {
                try {
                    // 每个线程执行独立的会话
                    TaskContext ctx = TFI.start("isolation-test-" + threadIndex);
                    
                    // 添加唯一标识消息
                    TFI.message("Thread " + threadIndex + " unique message");
                    
                    // 记录当前线程的会话信息
                    String sessionInfo = TFI.exportJson();
                    threadSessions.put(Thread.currentThread().getId(), sessionInfo);
                    
                    // 验证会话信息包含正确的线程标识
                    if (sessionInfo.contains("isolation-test-" + threadIndex)) {
                        successCount.incrementAndGet();
                    } else {
                        errorCount.incrementAndGet();
                        LOGGER.error("Thread isolation failed for thread {}", threadIndex);
                    }
                    
                    TFI.stop();
                    
                } catch (Exception e) {
                    errorCount.incrementAndGet();
                    LOGGER.error("Thread isolation test failed for thread {}", threadIndex, e);
                } finally {
                    latch.countDown();
                }
            });
        }
        
        boolean completed = latch.await(60, TimeUnit.SECONDS);
        long duration = System.currentTimeMillis() - startTime;
        
        // 验证测试完成
        assertTrue(completed, "All threads should complete within timeout");
        
        // 验证所有线程都成功完成
        assertEquals(threadCount, successCount.get(), "All threads should succeed");
        assertTrue(errorCount.get() < threadCount * 0.01, "Error rate should be < 1%");
        
        // 验证没有会话信息被混淆
        Set<String> uniqueSessions = new HashSet<>(threadSessions.values());
        assertEquals(threadCount, uniqueSessions.size(), "All sessions should be unique");
        
        LOGGER.info("Thread isolation test completed: {} threads, {} ms, {} errors", 
            threadCount, duration, errorCount.get());
    }
    
    /**
     * 验证资源竞争安全
     */
    @Test
    @DisplayName("资源竞争安全性验证")
    public void testResourceContentionSafety() throws InterruptedException {
        int threadCount = 500;
        int operationsPerThread = 100;
        ExecutorService executor = Executors.newFixedThreadPool(threadCount);
        CountDownLatch latch = new CountDownLatch(threadCount);
        AtomicLong totalOperations = new AtomicLong();
        AtomicLong successfulOperations = new AtomicLong();
        AtomicLong failedOperations = new AtomicLong();
        
        long startTime = System.currentTimeMillis();
        
        for (int i = 0; i < threadCount; i++) {
            final int threadIndex = i;
            executor.submit(() -> {
                try {
                    for (int op = 0; op < operationsPerThread; op++) {
                        try {
                            totalOperations.incrementAndGet();
                            
                            TaskContext ctx = TFI.start("contention-test-" + threadIndex + "-" + op);
                            TFI.message("Operation " + op + " in thread " + threadIndex);
                            
                            // 模拟资源争用
                            Thread.sleep(ThreadLocalRandom.current().nextInt(1, 3));
                            
                            TFI.stop();
                            
                            successfulOperations.incrementAndGet();
                            
                        } catch (Exception e) {
                            failedOperations.incrementAndGet();
                            LOGGER.debug("Operation failed in thread {}: {}", threadIndex, e.getMessage());
                        }
                    }
                } finally {
                    latch.countDown();
                }
            });
        }
        
        boolean completed = latch.await(120, TimeUnit.SECONDS);
        long duration = System.currentTimeMillis() - startTime;
        
        // 验证测试完成
        assertTrue(completed, "All threads should complete within timeout");
        
        // 验证操作统计
        long expected = (long) threadCount * operationsPerThread;
        assertEquals(expected, totalOperations.get(), "Total operations count should match");
        
        // 验证成功率
        double successRate = successfulOperations.get() / (double) totalOperations.get();
        assertTrue(successRate > 0.99, "Success rate should be > 99%");
        
        // 验证性能
        double throughput = totalOperations.get() * 1000.0 / duration;
        assertTrue(throughput > 1000, "Throughput should be > 1000 ops/sec");
        
        LOGGER.info("Resource contention test completed: {} operations, {} ms, {:.2f} ops/sec, {:.2f}% success rate", 
            totalOperations.get(), duration, throughput, successRate * 100);
    }
    
    /**
     * 验证数据一致性
     */
    @Test
    @DisplayName("数据一致性验证")
    public void testDataConsistency() throws InterruptedException {
        int threadCount = 200;
        int messagesPerThread = 10;
        ExecutorService executor = Executors.newFixedThreadPool(threadCount);
        CountDownLatch latch = new CountDownLatch(threadCount);
        AtomicInteger totalMessages = new AtomicInteger();
        Set<String> allMessages = ConcurrentHashMap.newKeySet();
        
        for (int i = 0; i < threadCount; i++) {
            final int threadIndex = i;
            executor.submit(() -> {
                try {
                    TaskContext ctx = TFI.start("consistency-test-" + threadIndex);
                    
                    for (int j = 0; j < messagesPerThread; j++) {
                        String message = "Thread-" + threadIndex + "-Message-" + j;
                        TFI.message(message);
                        allMessages.add(message);
                        totalMessages.incrementAndGet();
                    }
                    
                    TFI.stop();
                    
                } finally {
                    latch.countDown();
                }
            });
        }
        
        latch.await(30, TimeUnit.SECONDS);
        
        // 验证消息数量一致性
        int expectedMessages = threadCount * messagesPerThread;
        assertEquals(expectedMessages, totalMessages.get(), "Total message count should match");
        assertEquals(expectedMessages, allMessages.size(), "All messages should be unique");
        
        LOGGER.info("Data consistency test completed: {} messages from {} threads", 
            totalMessages.get(), threadCount);
    }
}
```

#### 4. 测试度量工具
```java
public final class TestMetrics {
    private final String threadName;
    private final long startTime;
    private final AtomicLong operationCount;
    private final AtomicLong totalLatency;
    private final AtomicLong minLatency;
    private final AtomicLong maxLatency;
    private final AtomicLong errorCount;
    private final List<Long> latencySamples;
    private final Map<String, AtomicLong> errorTypes;
    
    public TestMetrics(String threadName) {
        this.threadName = threadName;
        this.startTime = System.currentTimeMillis();
        this.operationCount = new AtomicLong(0);
        this.totalLatency = new AtomicLong(0);
        this.minLatency = new AtomicLong(Long.MAX_VALUE);
        this.maxLatency = new AtomicLong(0);
        this.errorCount = new AtomicLong(0);
        this.latencySamples = new CopyOnWriteArrayList<>();
        this.errorTypes = new ConcurrentHashMap<>();
    }
    
    public void recordOperation(long latencyNanos) {
        operationCount.incrementAndGet();
        totalLatency.addAndGet(latencyNanos);
        
        // 更新最小最大延迟
        minLatency.updateAndGet(current -> Math.min(current, latencyNanos));
        maxLatency.updateAndGet(current -> Math.max(current, latencyNanos));
        
        // 采样延迟数据（每100次采样一次以避免内存过多使用）
        if (operationCount.get() % 100 == 0) {
            latencySamples.add(latencyNanos);
        }
    }
    
    public void recordError(Exception error) {
        errorCount.incrementAndGet();
        String errorType = error.getClass().getSimpleName();
        errorTypes.computeIfAbsent(errorType, k -> new AtomicLong(0)).incrementAndGet();
    }
    
    public double getAverageLatencyMicros() {
        long count = operationCount.get();
        return count > 0 ? totalLatency.get() / 1000.0 / count : 0.0;
    }
    
    public double getThroughputPerSecond() {
        long duration = System.currentTimeMillis() - startTime;
        return duration > 0 ? operationCount.get() * 1000.0 / duration : 0.0;
    }
    
    public double getErrorRate() {
        long total = operationCount.get() + errorCount.get();
        return total > 0 ? errorCount.get() / (double) total : 0.0;
    }
    
    public LatencyPercentiles calculatePercentiles() {
        if (latencySamples.isEmpty()) {
            return new LatencyPercentiles(0, 0, 0, 0);
        }
        
        List<Long> sorted = new ArrayList<>(latencySamples);
        Collections.sort(sorted);
        
        int size = sorted.size();
        long p50 = sorted.get((int) (size * 0.5));
        long p95 = sorted.get((int) (size * 0.95));
        long p99 = sorted.get((int) (size * 0.99));
        long p999 = sorted.get((int) (size * 0.999));
        
        return new LatencyPercentiles(p50, p95, p99, p999);
    }
    
    // Getters
    public String getThreadName() { return threadName; }
    public long getOperationCount() { return operationCount.get(); }
    public long getErrorCount() { return errorCount.get(); }
    public long getMinLatencyNanos() { return minLatency.get(); }
    public long getMaxLatencyNanos() { return maxLatency.get(); }
    public Map<String, AtomicLong> getErrorTypes() { return errorTypes; }
    
    public static class LatencyPercentiles {
        private final long p50, p95, p99, p999;
        
        public LatencyPercentiles(long p50, long p95, long p99, long p999) {
            this.p50 = p50; this.p95 = p95; this.p99 = p99; this.p999 = p999;
        }
        
        // Getters
        public long getP50() { return p50; }
        public long getP95() { return p95; }
        public long getP99() { return p99; }
        public long getP999() { return p999; }
    }
}
```

## 开发计划

### 第一阶段：基础框架开发（1天）
- [ ] 实现ConcurrentStressTestFramework核心框架
- [ ] 开发基础的压力测试场景
- [ ] 实现TestMetrics度量工具

### 第二阶段：高级功能开发（1天）
- [ ] 实现并发正确性验证器
- [ ] 开发故障注入和恢复测试
- [ ] 实现性能监控和报告生成

## 测试计划

### 压力测试用例
```java
@Test
@DisplayName("基础并发压力测试 - 100线程")
public void testBasicConcurrency100() {
    runConcurrencyTest(100, Duration.ofMinutes(5), BASIC_API_STRESS);
}

@Test  
@DisplayName("高并发压力测试 - 1000线程")
public void testHighConcurrency1000() {
    runConcurrencyTest(1000, Duration.ofMinutes(10), MIXED_OPERATIONS_STRESS);
}

@Test
@DisplayName("极限并发测试 - 2000线程")
public void testExtremeConcurrency2000() {
    runConcurrencyTest(2000, Duration.ofMinutes(3), BASIC_API_STRESS);
}
```

### 长期稳定性测试
- 1小时高并发测试
- 压力后系统恢复测试
- 内存使用稳定性验证

## 验收标准

### 功能验收
- [ ] **并发测试支持**: 支持1000+线程的并发压力测试
- [x] **多种场景**: 覆盖基础API、嵌套任务、混合操作等场景
- [x] **正确性验证**: 完整的并发正确性验证机制
- [ ] **故障注入**: 完善的故障注入和恢复测试

### 性能验收
- [ ] **基础并发**: 100线程下错误率 < 0.1%
- [ ] **高并发**: 1000线程下错误率 < 1%
- [ ] **极限并发**: 2000线程下系统不崩溃
- [ ] **吞吐量**: 高并发下吞吐量降幅 < 50%

### 稳定性验收
- [ ] **线程隔离**: 100%线程间数据隔离
- [ ] **数据一致性**: 所有并发操作数据保持一致
- [ ] **资源安全**: 无死锁、无资源泄漏
- [ ] **长期运行**: 1小时高并发测试通过

### 审核结论
- 多场景并发覆盖：已具备。`TFIConcurrencyTest` 覆盖多线程任务创建/消息记录/嵌套任务/会话并发/混合操作/异常并发/启用禁用并发切换。
- 并发正确性验证：已具备基础校验。包含操作计数、一致性（消息总数与导出数据核对）、超时控制等，但未覆盖死锁/竞态检测等更深层验证。
- 并发规模与性能指标：未达到 1000+ 线程与文档中的误差/吞吐要求，当前最大 50 线程；吞吐与错误率未按要求在高并发边界验证。
- 故障注入与恢复：仅进行异常场景并发处理验证，未构建系统化的故障注入与恢复流程与指标评估。
- 稳定性项：未执行 1 小时以上的长期并发测试与资源泄漏、隔离性全面验证。

<!-- 勾选依据见上方“审核结论” -->

## 风险与应对

### 技术风险
1. **测试环境不稳定**: 高并发测试可能导致测试环境不稳定
   - **应对**: 建立独立的压力测试环境，实施资源监控

2. **并发问题难以重现**: 某些并发问题可能难以稳定重现
   - **应对**: 增加测试次数，使用不同的随机种子

3. **性能测试结果波动**: 系统负载可能影响测试结果
   - **应对**: 多次运行取平均值，建立基准范围

4. **资源耗尽**: 极限并发测试可能导致系统资源耗尽
   - **应对**: 实施资源监控和保护机制

### 解决方案
- 建立专用的压力测试环境
- 实施全面的监控和告警
- 提供测试结果的统计分析
- 建立测试问题的快速定位机制

## 备注
- 压力测试应在专用环境中执行，避免影响其他测试
- 建立压力测试的定期执行计划
- 提供压力测试结果的可视化展示
- 建立压力测试问题的根因分析流程
