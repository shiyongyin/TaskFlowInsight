# DEV-017: 内存泄漏检测实现

## 任务概述
**任务编号**: DEV-017  
**任务名称**: 内存泄漏检测实现  
**所属模块**: 性能测试模块  
**任务类型**: 安全性和稳定性开发  
**优先级**: 高  
**预估工时**: 2天  
**前置依赖**: 
- DEV-008: ThreadLocal内存管理
- DEV-007: ContextManager实现

## 业务需求
在多线程环境下，ThreadLocal使用不当容易引起内存泄漏。TaskFlowInsight需要建立完整的内存泄漏检测和预防机制，确保在Web应用和长期运行环境中的稳定性，特别是线程池复用场景下ThreadLocal数据的正确清理。

## 技术规格

### 核心功能
1. **ThreadLocal泄漏检测**
   - 实时监控ThreadLocal变量的生命周期
   - 检测死亡线程仍持有的内存资源
   - 识别长期不活跃线程的内存占用

2. **自动清理机制**
   - 线程结束时自动清理ThreadLocal数据
   - 不活跃线程的定期清理
   - 基于WeakReference的自动回收机制

3. **内存泄漏预警**
   - 达到内存阈值时主动告警
   - 提供详细的泄漏根因分析
   - 支持自定义监控规则和阈值

4. **统计分析功能**
   - 实时内存使用统计
   - 历史趋势分析
   - 泄漏模式识别

### 检测精度要求
- 死亡线程检测准确率：100%，60秒内检出
- 内存泄漏检测准确率：>95%，误报率<1%
- 清理效果：清理后内存使用降低>90%
- 性能影响：检测开销<1%总CPU使用

## 技术实现

### 文件结构
```
src/main/java/com/syy/taskflowinsight/memory/
├── MemoryLeakDetector.java              # 内存泄漏检测器主类
├── AutoCleanupManager.java              # 自动清理管理器
├── MemoryLeakListener.java              # 泄漏事件监听器接口
├── LeakDetectionConfig.java             # 检测配置类
├── ThreadMemoryInfo.java               # 线程内存信息追踪
├── MemoryLeakEvent.java                 # 内存泄漏事件
├── MemoryUsageReporter.java             # 内存使用报告器
└── WeakReferenceCleanup.java            # 弱引用清理机制

src/test/java/com/syy/taskflowinsight/memory/
├── MemoryLeakDetectionTest.java         # 内存泄漏检测测试
├── AutoCleanupManagerTest.java          # 自动清理测试
└── MemoryLeakIntegrationTest.java       # 集成测试
```

### 核心实现

#### 1. 内存泄漏检测器
```java
public final class MemoryLeakDetector {
    private static final Logger LOGGER = LoggerFactory.getLogger(MemoryLeakDetector.class);
    
    // 检测配置常量
    private static final long LEAK_DETECTION_INTERVAL_MS = 60_000; // 1分钟检测一次
    private static final long INACTIVE_THRESHOLD_MS = 300_000;     // 5分钟无活动视为不活跃
    private static final long MEMORY_WARNING_THRESHOLD_MB = 10;    // 10MB告警阈值
    private static final int MAX_INACTIVE_THREADS = 100;           // 最大不活跃线程数
    
    private final ScheduledExecutorService detectionExecutor;
    private final ConcurrentHashMap<Long, ThreadMemoryInfo> threadMemoryMap;
    private final List<MemoryLeakListener> listeners;
    private final AtomicBoolean isDetectionEnabled;
    private final AtomicLong detectionCycles;
    
    public MemoryLeakDetector() {
        this.detectionExecutor = Executors.newSingleThreadScheduledExecutor(
            r -> new Thread(r, "TFI-MemoryLeakDetector")
        );
        this.threadMemoryMap = new ConcurrentHashMap<>();
        this.listeners = new CopyOnWriteArrayList<>();
        this.isDetectionEnabled = new AtomicBoolean(true);
        this.detectionCycles = new AtomicLong(0);
        
        startDetection();
    }
    
    public void registerThread(long threadId, String threadName) {
        ThreadMemoryInfo memInfo = new ThreadMemoryInfo(threadId, threadName);
        threadMemoryMap.put(threadId, memInfo);
        LOGGER.debug("Registered thread for memory monitoring: {} ({})", threadName, threadId);
    }
    
    public void updateThreadActivity(long threadId) {
        ThreadMemoryInfo memInfo = threadMemoryMap.get(threadId);
        if (memInfo != null) {
            memInfo.updateActivity();
        }
    }
    
    public void unregisterThread(long threadId) {
        ThreadMemoryInfo removed = threadMemoryMap.remove(threadId);
        if (removed != null) {
            LOGGER.debug("Unregistered thread from memory monitoring: {}", threadId);
        }
    }
    
    private void startDetection() {
        detectionExecutor.scheduleAtFixedRate(
            this::performLeakDetection,
            LEAK_DETECTION_INTERVAL_MS,
            LEAK_DETECTION_INTERVAL_MS,
            TimeUnit.MILLISECONDS
        );
    }
    
    private void performLeakDetection() {
        if (!isDetectionEnabled.get()) {
            return;
        }
        
        try {
            long cycleNumber = detectionCycles.incrementAndGet();
            long currentTime = System.currentTimeMillis();
            
            LOGGER.debug("Starting memory leak detection cycle #{}", cycleNumber);
            
            DetectionResult result = analyzeMemoryUsage(currentTime);
            
            // 处理检测结果
            handleDeadThreads(result.getDeadThreads());
            handleInactiveThreads(result.getInactiveThreads());
            checkMemoryThresholds(result.getTotalMemoryUsage(), result.getThreadCount());
            
            LOGGER.debug("Completed memory leak detection cycle #{}: {} threads monitored, {} MB total usage",
                cycleNumber, result.getThreadCount(), result.getTotalMemoryUsage() / 1024 / 1024);
                
        } catch (Exception e) {
            LOGGER.error("Error during memory leak detection", e);
        }
    }
    
    private DetectionResult analyzeMemoryUsage(long currentTime) {
        Set<Long> deadThreads = new HashSet<>();
        Set<Long> inactiveThreads = new HashSet<>();
        long totalMemoryUsage = 0;
        int activeThreadCount = 0;
        
        for (Map.Entry<Long, ThreadMemoryInfo> entry : threadMemoryMap.entrySet()) {
            Long threadId = entry.getKey();
            ThreadMemoryInfo memInfo = entry.getValue();
            
            // 检测线程是否已死亡
            if (isThreadDead(threadId)) {
                deadThreads.add(threadId);
                notifyDeadThreadDetected(threadId, memInfo);
                continue;
            }
            
            // 检测长期不活跃线程
            if (currentTime - memInfo.getLastActiveTime() > INACTIVE_THRESHOLD_MS) {
                inactiveThreads.add(threadId);
            }
            
            totalMemoryUsage += memInfo.getEstimatedMemoryUsage();
            activeThreadCount++;
        }
        
        return new DetectionResult(deadThreads, inactiveThreads, totalMemoryUsage, activeThreadCount);
    }
    
    private boolean isThreadDead(long threadId) {
        return ThreadUtils.isThreadDead(threadId);
    }
    
    private void handleDeadThreads(Set<Long> deadThreads) {
        for (Long threadId : deadThreads) {
            cleanupDeadThread(threadId);
        }
    }
    
    private void cleanupDeadThread(long threadId) {
        ThreadMemoryInfo memInfo = threadMemoryMap.remove(threadId);
        if (memInfo != null) {
            LOGGER.warn("Cleaned up dead thread resources: {} ({})", memInfo.getThreadName(), threadId);
            
            // 通知监听器
            MemoryLeakEvent event = new MemoryLeakEvent(
                MemoryLeakType.DEAD_THREAD,
                threadId,
                memInfo.getThreadName(),
                memInfo.getEstimatedMemoryUsage(),
                System.currentTimeMillis(),
                "Dead thread with unreleased resources detected"
            );
            
            notifyListeners(listener -> listener.onDeadThreadDetected(event));
        }
    }
    
    private void notifyListeners(Consumer<MemoryLeakListener> action) {
        for (MemoryLeakListener listener : listeners) {
            try {
                action.accept(listener);
            } catch (Exception e) {
                LOGGER.error("Error notifying memory leak listener", e);
            }
        }
    }
}
```

#### 2. 线程内存信息追踪
```java
public static final class ThreadMemoryInfo {
    private final long threadId;
    private final String threadName;
    private final long createdTime;
    private volatile long lastActiveTime;
    private volatile long estimatedMemoryUsage;
    private volatile int sessionCount;
    private volatile int taskNodeCount;
    private final AtomicLong totalApiCalls;
    private final Set<String> activeSessions;
    
    public ThreadMemoryInfo(long threadId, String threadName) {
        this.threadId = threadId;
        this.threadName = threadName;
        this.createdTime = System.currentTimeMillis();
        this.lastActiveTime = createdTime;
        this.estimatedMemoryUsage = 0;
        this.sessionCount = 0;
        this.taskNodeCount = 0;
        this.totalApiCalls = new AtomicLong(0);
        this.activeSessions = ConcurrentHashMap.newKeySet();
    }
    
    public void updateActivity() {
        this.lastActiveTime = System.currentTimeMillis();
        this.totalApiCalls.incrementAndGet();
    }
    
    public void updateMemoryUsage(long memoryDelta) {
        this.estimatedMemoryUsage += memoryDelta;
    }
    
    public void addSession(String sessionId) {
        activeSessions.add(sessionId);
        sessionCount++;
        // 估算每个Session约占用的内存
        updateMemoryUsage(1024); // 1KB per session estimate
    }
    
    public void removeSession(String sessionId) {
        if (activeSessions.remove(sessionId)) {
            sessionCount = Math.max(0, sessionCount - 1);
            updateMemoryUsage(-1024); // Release session memory
        }
    }
    
    public void addTaskNode() {
        taskNodeCount++;
        updateMemoryUsage(512); // 512B per task node estimate
    }
    
    public void removeTaskNode() {
        taskNodeCount = Math.max(0, taskNodeCount - 1);
        updateMemoryUsage(-512);
    }
    
    public long getEstimatedMemoryUsage() {
        return Math.max(0, estimatedMemoryUsage);
    }
    
    public boolean isInactive(long currentTime, long inactiveThreshold) {
        return currentTime - lastActiveTime > inactiveThreshold;
    }
    
    public long getInactiveTime(long currentTime) {
        return currentTime - lastActiveTime;
    }
    
    // Getters
    public long getThreadId() { return threadId; }
    public String getThreadName() { return threadName; }
    public long getCreatedTime() { return createdTime; }
    public long getLastActiveTime() { return lastActiveTime; }
    public int getSessionCount() { return sessionCount; }
    public int getTaskNodeCount() { return taskNodeCount; }
    public long getTotalApiCalls() { return totalApiCalls.get(); }
    public int getActiveSessionsCount() { return activeSessions.size(); }
}
```

#### 3. 自动清理管理器
```java
public final class AutoCleanupManager {
    private static final Logger LOGGER = LoggerFactory.getLogger(AutoCleanupManager.class);
    
    private final WeakHashMap<Thread, ThreadContextRef> threadContextMap = new WeakHashMap<>();
    private final ReferenceQueue<ThreadContext> cleanupQueue = new ReferenceQueue<>();
    private final ScheduledExecutorService cleanupExecutor;
    private final AtomicBoolean isActive;
    
    public AutoCleanupManager() {
        this.cleanupExecutor = Executors.newSingleThreadScheduledExecutor(
            r -> new Thread(r, "TFI-AutoCleanup")
        );
        this.isActive = new AtomicBoolean(true);
        startCleanupMonitoring();
    }
    
    public void registerThreadContext(Thread thread, ThreadContext context) {
        synchronized (threadContextMap) {
            ThreadContextRef ref = new ThreadContextRef(
                context, 
                thread.getId(), 
                thread.getName(),
                cleanupQueue
            );
            threadContextMap.put(thread, ref);
        }
        
        LOGGER.debug("Registered ThreadContext for cleanup monitoring: {} ({})", 
            thread.getName(), thread.getId());
    }
    
    public void unregisterThreadContext(Thread thread) {
        synchronized (threadContextMap) {
            ThreadContextRef ref = threadContextMap.remove(thread);
            if (ref != null) {
                ref.clear();
                LOGGER.debug("Unregistered ThreadContext: {} ({})", 
                    thread.getName(), thread.getId());
            }
        }
    }
    
    private void startCleanupMonitoring() {
        cleanupExecutor.scheduleAtFixedRate(
            this::processCleanupQueue,
            5000,  // 5秒延迟
            1000,  // 每秒检查一次
            TimeUnit.MILLISECONDS
        );
    }
    
    private void processCleanupQueue() {
        if (!isActive.get()) {
            return;
        }
        
        ThreadContextRef ref;
        int cleanedCount = 0;
        
        while ((ref = (ThreadContextRef) cleanupQueue.poll()) != null) {
            try {
                long threadId = ref.getThreadId();
                String threadName = ref.getThreadName();
                
                LOGGER.debug("Auto-cleaning resources for dead thread: {} ({})", threadName, threadId);
                
                // 触发清理逻辑
                cleanupDeadThreadResources(threadId);
                cleanedCount++;
                
            } catch (Exception e) {
                LOGGER.error("Error during automatic cleanup", e);
            }
        }
        
        if (cleanedCount > 0) {
            LOGGER.info("Auto-cleaned resources for {} dead threads", cleanedCount);
        }
    }
    
    private void cleanupDeadThreadResources(long threadId) {
        // 清理ThreadLocal数据
        ThreadContextManager.cleanupThreadContext(threadId);
        
        // 通知内存泄漏检测器
        MemoryLeakDetector.getInstance().unregisterThread(threadId);
        
        // 清理其他相关资源
        SessionManager.cleanupThreadSessions(threadId);
    }
    
    // 弱引用包装类
    private static final class ThreadContextRef extends WeakReference<ThreadContext> {
        private final long threadId;
        private final String threadName;
        
        public ThreadContextRef(ThreadContext referent, long threadId, String threadName, 
                               ReferenceQueue<ThreadContext> queue) {
            super(referent, queue);
            this.threadId = threadId;
            this.threadName = threadName;
        }
        
        public long getThreadId() { return threadId; }
        public String getThreadName() { return threadName; }
    }
}
```

#### 4. 内存泄漏事件和监听器
```java
public interface MemoryLeakListener {
    void onDeadThreadDetected(MemoryLeakEvent event);
    void onInactiveThreadsExceeded(MemoryLeakEvent event);
    void onMemoryThresholdExceeded(MemoryLeakEvent event);
    void onThreadMemoryAnomaly(MemoryLeakEvent event);
}

public static final class MemoryLeakEvent {
    private final MemoryLeakType type;
    private final long threadId;
    private final String threadName;
    private final long memoryUsage;
    private final long timestamp;
    private final String details;
    
    public MemoryLeakEvent(MemoryLeakType type, long threadId, String threadName,
                          long memoryUsage, long timestamp, String details) {
        this.type = type;
        this.threadId = threadId;
        this.threadName = threadName;
        this.memoryUsage = memoryUsage;
        this.timestamp = timestamp;
        this.details = details;
    }
    
    // Getters and toString method
}

public enum MemoryLeakType {
    DEAD_THREAD("Dead thread with unreleased resources"),
    INACTIVE_THREADS_EXCEEDED("Too many inactive threads"),
    MEMORY_THRESHOLD_EXCEEDED("Memory usage threshold exceeded"),
    THREAD_MEMORY_ANOMALY("Thread memory usage anomaly");
    
    private final String description;
    
    MemoryLeakType(String description) {
        this.description = description;
    }
    
    public String getDescription() { return description; }
}
```

## 开发计划

### 第一阶段：核心检测机制（1天）
- [ ] 实现MemoryLeakDetector基础框架
- [ ] 开发ThreadMemoryInfo追踪机制
- [ ] 实现基本的死亡线程检测逻辑

### 第二阶段：自动清理和监听（1天）
- [ ] 实现AutoCleanupManager和弱引用清理
- [ ] 开发MemoryLeakListener事件机制
- [ ] 实现内存使用统计和报告功能

## 测试计划

### 单元测试
```java
@Test
public void testDeadThreadDetection() {
    // 创建线程并立即销毁，验证检测器能够发现
    Thread testThread = new Thread(() -> {
        TFI.start("test-task");
        // 线程结束但不调用cleanup
    });
    testThread.start();
    testThread.join();
    
    // 等待检测周期
    Thread.sleep(65000);
    
    // 验证死亡线程被检测到
    verify(mockListener).onDeadThreadDetected(any(MemoryLeakEvent.class));
}

@Test
public void testInactiveThreadDetection() {
    // 创建不活跃线程测试
}

@Test
public void testMemoryThresholdDetection() {
    // 测试内存阈值告警
}

@Test
public void testAutoCleanupMechanism() {
    // 测试自动清理机制
}
```

### 集成测试
- 长期运行测试（24小时）
- 大量短生命周期线程测试
- Web容器环境下的线程池测试
- 内存压力测试

## 验收标准

### 功能验收
- [ ] **ThreadLocal泄漏检测**: 准确检测死亡线程持有的ThreadLocal数据
- [x] **自动清理机制**: 死亡线程资源能够自动清理
- [ ] **内存使用统计**: 准确统计各线程的内存使用情况
- [x] **泄漏事件监听**: 完善的事件监听和通知机制

### 性能验收
- [ ] **检测延迟**: 死亡线程检测延迟 < 60秒
- [ ] **检测准确率**: 内存泄漏检测准确率 > 95%
- [ ] **误报率**: 误报率 < 1%
- [ ] **性能影响**: 检测开销 < 1% CPU使用

### 稳定性验收
- [ ] **长期运行**: 24小时运行无内存泄漏
- [ ] **清理效果**: 清理后内存使用降低 > 90%
- [ ] **异常处理**: 各种异常情况下检测器正常工作
- [ ] **并发安全**: 多线程环境下检测器线程安全

### 审核结论
- 自动清理与死线程清理：已具备。`SafeContextManager` 提供定时泄漏检测与 `LeakListener`，`ZeroLeakThreadLocalManager` 提供死线程弱引用队列与周期清理。
- 泄漏事件监听：已具备。`SafeContextManager` 支持注册 `LeakListener` 并在检测到泄漏时回调。
- ThreadLocal 泄漏检测：当前实现基于“上下文泄漏/死线程”的检测与清理，诊断模式可选用反射清理 ThreadLocal，但未实现通用的 ThreadLocal 生命周期监控与精确统计，故暂不勾选。
- 内存使用统计/阈值预警/趋势分析：未实现每线程的内存使用统计与阈值告警。
- 稳定性与性能指标（检测延迟/准确率/误报率等）：缺乏长期运行与系统性验证，暂不勾选。

<!-- 勾选依据见上方“审核结论” -->

## 风险与应对

### 技术风险
1. **检测精度问题**: 可能出现误报或漏报
   - **应对**: 实施多重验证机制，调优检测算法

2. **性能影响**: 检测机制可能影响应用性能
   - **应对**: 优化检测算法，实施懒加载和批处理

3. **线程状态判断**: 线程死亡状态判断可能不准确
   - **应对**: 使用多种方法交叉验证线程状态

4. **内存估算偏差**: 内存使用估算可能不准确
   - **应对**: 实施动态校准机制，使用实际测量数据

### 解决方案
- 建立完善的测试用例覆盖各种场景
- 实施性能监控和优化
- 提供可配置的检测参数
- 建立检测准确性的持续改进机制

## 备注
- 内存泄漏检测应该是可选功能，生产环境可根据需要开启
- 提供详细的配置文档和最佳实践
- 建立与现有监控系统的集成接口
- 考虑不同JVM版本和GC算法的兼容性
